<!DOCTYPE html>
<html>
    <head>
        <!--게임의 제목과 폰트 등을 정의한다.-->
        <title>Fruit in basket</title>
        <link href='http://fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'/>
        <style>
            /*body부분의 폰트, 글자 위치, 배경색을 지정한다.*/
            body {
                height: 100%;
                font-family: Slackey;
                text-align: center;
                background: #20202c;
            }
            /*h1의 폰트 크기와 색상을 지정하고 그림자 효과를 적용한다.*/
            h1 {
                color: #DA2647;
                font-size: 3em;
                text-shadow: 2px 2px 5px #AAF0D1;
            }
            /*h1 span의 색상을 지정한다.*/
            h1 span {
                color: #29AB87;
            }
            /*stage의 너비를 500px, 높이를 50px, 글자의 위치는 중앙으로 지정하고 글씨의 크기와 색상을 지정한다.*/
            #stage {
                width: 500px;
                height: 50px;
                margin: 30px auto;
                font-size: 3em;
                text-align: center;
                color: #ac7fa6;
            }
            /*score의 너비를 500px, 높이를 50px, 글자의 위치는 중앙으로 지정하고 글씨의 크기와 색상을 지정한다.*/
            #score {
                width: 500px;
                height: 50px;
                margin: 30px auto;
                font-size: 4em;
                text-align: center;
                color: #C3CDE6;
            }
            /*너비 800px, 높이 500px, 테두리 효과 등을 적용한 id=board인 div를 원하는 위치에 지정한다.*/
            #board {
                position: relative;
                margin: 50px auto;
                width: 800px;
                height: 500px;
                border: 6px solid #29AB87;
                box-shadow: 0 0 1px rgba(0,0,0,0.2);
                background: linear-gradient(to bottom, #b7eaff 0%, #94dfff 100%);
            }
            /*너비 100px, 높이 58px, id=basket인 div를 원하는 위치에 지정한다.*/
            #basket {
                position: absolute;
                width: 100px;
                height: 58px;
                background: url(img/basket.png);
                z-index: 50;
            }
            /*너비 30px, 높이 30px, class=apple인 div를 원하는 위치에 지정한다.*/
            .apple {
                position: absolute;
                width: 30px;
                height: 30px;
                border-radius: 15px;
                background: url(img/apple.png);
            }
            /*너비 30px, 높이 30px, class=orange인 div를 원하는 위치에 지정한다.*/            
            .orange {
                position: absolute;
                width: 30px;
                height: 30px;                
                background: url(img/orange.png);
            }
            /*너비 50px, 높이 38px, class=worm인 div를 원하는 위치에 지정한다.*/
            .worm {
                position: absolute;
                width: 50px;
                height: 38px;                
                background: url(img/worm.png);
            }
            /*너비 50px, 높이 52px, class=bomb인 div를 원하는 위치에 지정한다.*/
            .bomb {
                position: absolute;
                width: 50px;
                height: 52px;                
                background: url(img/bomb.png);
            }
            /*너비 300px, 높이 200px, id=gameover인 div를 위에서 100px, 왼쪽에서 250px의 위치에 보이지 않도록 지정한다.
            z-index=100으로 하여 제일 위에 나타나도록 한다.*/
            #gameOver {
                display: none;
                position: absolute;
                top: 100px;
                left: 250px;
                width: 300px;
                height: 200px;
                background-color: white;
                border: 2px solid red;
                border-radius: 8px;
                z-index: 100;
            }
            /*너비 100px, 높이 53px, class=cloud인 div를 원하는 위치에 지정한다.*/
            .cloud {
                position: absolute;
                width: 100px;
                height: 53px;                
                background: url(img/cloud.png);
                z-index: 70;
            }
        </style>
        <script>
            /**********
                Fruit in basket 게임은 사과, 오렌지 등 위에서 떨어지는 과일을 바구니로 받는 게임으로,
                폭탄을 받으면 포인트가 감점되고 벌레를 받으면 게임이 종료된다.
                아이템:
                    -사과: 받으면 +10점
                    -오렌지: 받으면 +20점
                    -폭탄: 받으면 -30점
                    -벌레: 받으면 게임오버
                    -구름: 시각 방해요소로 다양한 opacity를 가진다.
                레벨:
                    1단계: 사과만 아이템으로 나온다. 100점이 넘으면 다음 단계
                    2단계: 오렌지와 폭탄 추가 200점이 넘으면 다음단계
                    3단계: 벌레 추가 300점이 넘으면 다음단계
                    4단계: 구름 추가
                효과음:
                    -포인트 획득시 성공 효과음
                    -게임오버
                입력:
                    -키 이벤트: 화살표키로 바구니이동
                게임 종료시 최고 점수 3개를 보여준다.
            **********/
            /*
            let과 const를 이용하여 변수를 선언
            const 선언자는 블록유효범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다.
            */
            let STEP = 8;
            let GAP = 5;
            const APPLE_POINT = 10;
            const ORANGE_POINT = 20;
            const BOMB_POINT = (-30);
            const SCORE_ARRAY = 'basketGameScores';
            const MAX_SCORES = 3;

            window.onload = function() {
                let basketElement = document.getElementById('basket');
                // getElementById 메서드를 이용하여 id값 'basket'으로 요소 객체를 가져와 변수 basketElement를 선언한다.
                let boardElement = document.getElementById('board');
                // getElementById 메서드를 이용하여 id값 'board'로 요소 객체를 가져와 변수 boardElement를 선언한다.
                let scoreElement = document.getElementById('score');
                // getElementById 메서드를 이용하여 id값 'score'로 요소 객체를 가져와 변수 scoreElement를 선언한다.
                let stageElement = document.getElementById('stage');
                // getElementById 메서드를 이용하여 id값 'stage'로 요소 객체를 가져와 변수 stageElement를 선언한다.
                
                // basket에 변수 basketElement와 STEP을 저장한 Basket 생성자를 이용하여 객체를 생성하고 선언한다.
                let basket = new Basket(basketElement, STEP);
                // board에 변수 boardElement, basket, scoreElement, stageElement를 저장한 Board 생성자를 이용하여 객체를 생성하고 선언한다.
                let board = new Board(boardElement, basket, scoreElement, stageElement);
            };

            // Basket 생성자 정의
            function Basket(element, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.element = element;
                this.step = step;

                this.init = function() {
                    // basket의 위치를 지정한다.
                    this.element.style.top = '440px';
                    this.element.style.left = '350px';
                    this.gameOver = false;

                    // 키 이벤트 등록
                    this.registerEvents();
                };
                // 위쪽 이동 함수 정의
                this.moveUp = function() {                    
                    this.element.style.top = (parseInt(this.element.style.top) - this.step) + 'px';
                };
                // 아래쪽 이동 함수 정의
                this.moveDown = function() {
                    this.element.style.top = (parseInt(this.element.style.top) + this.step) + 'px';
                };
                // 왼쪽 이동 함수 정의
                this.moveLeft = function() {
                    this.element.style.left = (parseInt(this.element.style.left) - this.step) + 'px';
                };
                // 오른쪽 이동 함수 정의
                this.moveRight = function() {
                    this.element.style.left = (parseInt(this.element.style.left) + this.step) + 'px';
                };

                // 요소의 크기와 방향을 통해 위치 값을 반환하는 함수를 정의한다.    
                this.getClientRect = function() {
                    return this.element.getBoundingClientRect();
                }

                this.onMove = function() {
                    console.log('basket is moving');
                }

                // 게임 오버시 이벤트를 무시하는(멈추는) 함수 정의
                this.ignoreKeysEvents = function() {
                    this.gameOver = true;
                }

                // 키 이벤트 정의
                this.registerEvents = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 해당하는 키보드의 키를 눌렀을 때 이벤트가 발생하도록 이벤트 리스너를 등록한다.
                    document.addEventListener('keydown', function(e){
                        // 게임 오버시 다시 반환한다.(작동되지 않음)
                        if (self.gameOver == true) return;
                        // 40초과 그리고 37미만의 키 코드에 해당하는 키를 누르면 다시 반환한다.(작동되지 않음)
                        if ((e.keyCode > 40) || (e.keyCode < 37)) return;
                        // basket의 왼쪽 위치와 위쪽 위치를 10진수로 변환하여 변수로 선언한다.
                        let leftPosition = parseInt(basket.style.left, 10);
                        let topPosition = parseInt(basket.style.top, 10);
                        // 각 keyCode에 해당하는 키를 누르면 해당 방향으로 이동한다.(단, basket은 특정 공간 밖으로 이동하지 않음)
                        if (e.keyCode == 37) {
                            if (leftPosition < 6) return;
                            self.moveLeft();
                        } else if (e.keyCode == 38) {
                            if (topPosition < 8) return;
                            self.moveUp();
                        } else if (e.keyCode == 39) {
                            if (leftPosition > 694) return;
                            self.moveRight();
                        } else if (e.keyCode == 40) {
                            if (topPosition > 439) return;
                            self.moveDown();
                        }

                        self.onMove();
                    });
                }
                this.init();
            }

            // Apple 생성자 정의
            function Apple(container, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.container = container;
                this.step = step;

                this.init = function() {
                    // div 노드 객체를 생성한다.
                    this.element = document.createElement('div');
                    // class 속성의 속성 값을 apple로 설정한다.
                    this.element.setAttribute('class', 'apple');

                    // apple요소를 위에서 20px, 왼쪽으로 부터는 20px에서 (750-20+1)=731px까지의 랜덤 위치에서 생성한다.
                    this.element.style.top = '20px';
                    this.element.style.left = randomRange(20, 750) + 'px';
                    // this.container에 this.element 노드를 삽입한다.
                    this.container.appendChild(this.element);

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 0.35초에 한 번씩 요소가 나타나도록 타이머를 설정한다.
                    this.timerId = setInterval(function(){
                        // apple 요소가 한 번 움직인 후의 위치를 변수에 선언
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        // apple요소가 바닥에 닿으면 타이머가 종료되면서 사라진다.
                        if (topPosition >= 470) {
                            self.element.remove();
                            clearInterval(self.timerId);
                        } else {
                            self.element.style.top = topPosition + 'px';
                            self.onMove(self.element.getBoundingClientRect());
                        }
                    }, 350);
                };

                // apple 요소가 제거되며 타이머 종료 함수
                this.remove = function() {
                    clearInterval(this.timerId);
                    this.element.remove();
                    this.onDie();
                }

                // apple 요소 타이머 종료 함수
                this.stop = function() {
                    clearInterval(this.timerId);
                }

                // 특정 명령에 반응하여 이동시키는 함수
                this.onMove = function(clientRect) {
                    console.log('this is event method fired on moving');
                };

                // apple 요소 제거 함수
                this.onDie = function() {
                    console.log('apple is removed');
                }

                // 요소의 크기와 방향을 통해 위치 값을 반환하는 함수를 정의한다.
                this.getRectangle = function() {
                    return this.element.getBoundingClientRect();
                }

                this.init();
            }

            // Orange 생성자 정의
            function Orange(container, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.container = container;
                this.step = step;

                this.init = function() {
                    // div 노드 객체를 생성한다.
                    this.element = document.createElement('div');
                    // class 속성의 속성 값을 orange로 설정한다.
                    this.element.setAttribute('class', 'orange');

                    // orange요소를 위에서 20px, 왼쪽으로 부터는 20px에서 731px까지의 랜덤 위치에서 생성한다.
                    this.element.style.top = '20px';
                    this.element.style.left = randomRange(20, 750) + 'px';
                    // this.container에 this.element 노드를 삽입한다.
                    this.container.appendChild(this.element);

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 0.4초에 한 번씩 요소가 나타나도록 타이머를 설정한다.
                    this.timerId = setInterval(function(){
                        // orange 요소가 한 번 움직인 후의 위치를 변수에 선언
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        // orange요소가 바닥에 닿으면 타이머가 종료되면서 사라진다.
                        if (topPosition >= 470) {
                            self.element.remove();
                            clearInterval(self.timerId);
                        } else {
                            self.element.style.top = topPosition + 'px';
                            self.onMove(self.element.getBoundingClientRect());
                        }
                    }, 400);
                };

                // orange 요소가 제거되며 타이머 종료 함수
                this.remove = function() {
                    clearInterval(this.timerId);
                    this.element.remove();
                    this.onDie();
                }

                // orange 요소 타이머 종료 함수
                this.stop = function() {
                    clearInterval(this.timerId);
                }

                // 특정 명령에 반응하여 이동시키는 함수
                this.onMove = function(clientRect) {
                    console.log('this is event method fired on moving');
                };

                // orange 요소 제거 함수
                this.onDie = function() {
                    console.log('orange is removed');
                }

                // 요소의 크기와 방향을 통해 위치 값을 반환하는 함수를 정의한다.
                this.getRectangle = function() {
                    return this.element.getBoundingClientRect();
                }

                this.init();
            }

            // Bomb 생성자 정의
            function Bomb(container, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.container = container;
                this.step = step;

                this.init = function() {
                    // div 노드 객체를 생성한다.
                    this.element = document.createElement('div');
                    // class 속성의 속성 값을 bomb로 설정한다.
                    this.element.setAttribute('class', 'bomb');

                    // bomb요소를 위에서 20px, 왼쪽으로 부터는 20px에서 731px까지의 랜덤 위치에서 생성한다.
                    this.element.style.top = '20px';
                    this.element.style.left = randomRange(20, 750) + 'px';
                    // this.container에 this.element 노드를 삽입한다.
                    this.container.appendChild(this.element);

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 0.1초에 한 번씩 요소가 나타나도록 타이머를 설정한다.
                    this.timerId = setInterval(function(){
                        // bomb 요소가 한 번 움직인 후의 위치를 변수에 선언
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        // bomb요소가 바닥에 닿으면 타이머가 종료되면서 사라진다.
                        if (topPosition >= 450) {
                            self.element.remove();
                            clearInterval(self.timerId);
                        } else {
                            self.element.style.top = topPosition + 'px';
                            self.onMove(self.element.getBoundingClientRect());
                        }
                    }, 100);
                };

                // bomb 요소가 제거되며 타이머 종료 함수
                this.remove = function() {
                    clearInterval(this.timerId);
                    this.element.remove();
                    this.onDie();
                }

                // bomb 요소 타이머 종료 함수
                this.stop = function() {
                    clearInterval(this.timerId);
                }

                // 특정 명령에 반응하여 이동시키는 함수
                this.onMove = function(clientRect) {
                    console.log('this is event method fired on moving');
                };

                // bomb 요소 제거 함수
                this.onDie = function() {
                    console.log('bomb is removed');
                }

                // 요소의 크기와 방향을 통해 위치 값을 반환하는 함수를 정의한다.
                this.getRectangle = function() {
                    return this.element.getBoundingClientRect();
                }

                this.init();
            }            
            
            // Worm 생성자 정의
            function Worm (container, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.container = container;
                this.step = step;

                this.init = function() {
                    // div 노드 객체를 생성한다.
                    this.element = document.createElement('div');
                    // class 속성의 속성 값을 worm로 설정한다.
                    this.element.setAttribute('class', 'worm');

                    // worm요소를 위에서 20px, 왼쪽으로 부터는 100px에서 (700-100+1)=601px까지의 랜덤 위치에서 생성한다.
                    this.element.style.top = '20px';
                    this.element.style.left = randomRange(100, 700) + 'px';
                    // this.container에 this.element 노드를 삽입한다.
                    this.container.appendChild(this.element);

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 0.1초에 한 번씩 요소가 나타나도록 타이머를 설정한다.
                    this.timerId = setInterval(function(){
                        // worm 요소가 한 번 움직인 후의 위치를 변수에 선언
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        // worm 요소가 바닥에 닿으면 타이머가 종료되면서 사라진다.
                        if (topPosition >= 470) {
                            self.element.remove();
                            clearInterval(self.timerId);
                        } else {
                            self.element.style.top = topPosition + 'px';
                            self.onMove(self.element.getBoundingClientRect());
                        }
                    }, 100);
                };

                // worm 요소가 제거되며 타이머 종료 함수
                this.remove = function() {
                    clearInterval(this.timerId);
                    this.element.remove();
                }

                // worm 요소 타이머 종료 함수
                this.stop = function() {
                    clearInterval(this.timerId);
                }

                // 특정 명령에 반응하여 이동시키는 함수
                this.onMove = function(clientRect) {
                    console.log('this is event method fired on moving');
                };

                this.init();
            }

            // Cloud 생성자 정의
            function Cloud(container, step) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.container = container;
                this.step = step;

                this.init = function() {
                    // div 노드 객체를 생성한다.
                    this.element = document.createElement('div');
                    // class 속성의 속성 값을 cloud로 설정한다.
                    this.element.setAttribute('class', 'cloud');

                    // cloud요소를 위에서 20px, 왼쪽으로 부터는 100px에서 601px까지의 랜덤 위치에서 생성한다.
                    this.element.style.top = '20px';
                    this.element.style.left = randomRange(100, 700) + 'px';
                    // this.container에 this.element 노드를 삽입한다.
                    this.container.appendChild(this.element);

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // 0.25초에 한 번씩 요소가 나타나도록 타이머를 설정한다.
                    this.timerId = setInterval(function(){
                        // cloud 요소가 한 번 움직인 후의 위치를 변수에 선언
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        // cloud 요소가 바닥에 닿으면 타이머가 종료되면서 사라진다.
                        if (topPosition >= 440) {
                            self.element.remove();
                            clearInterval(self.timerId);
                        } else {
                            self.element.style.top = topPosition + 'px';
                            self.onMove(self.element.getBoundingClientRect());
                        }
                    }, 250);
                };

                // cloud 요소 타이머 종료 함수
                this.stop = function() {
                    clearInterval(this.timerId);
                }

                // 특정 명령에 반응하여 이동시키는 함수
                this.onMove = function(clientRect) {
                    console.log('this is event method fired on moving');
                };

                // 요소의 크기와 방향을 통해 위치 값을 반환하는 함수를 정의한다.
                this.getRectangle = function() {
                    return this.element.getBoundingClientRect();
                }

                this.init();
            }

            // Board 생성자 정의
            function Board(element, basket, scoreElement, stageElement) {
                // this를 사용하여 각각의 값이 인스턴스의 프로퍼티임을 명시한다.
                this.element = element;
                this.basket = basket;
                this.scoreElement = scoreElement;
                this.stageElement = stageElement;
                this.apples = [];
                this.oranges = [];
                this.worms = [];
                this.bombs = [];
                this.clouds = [];

                // 점수(score)와 레벨(stage) 지정
                this.init = function() {
                    this.score = 0;
                    this.stage = 1;

                    // this를 self 변수로 선언한다.
                    let self = this;
                    // apple 요소 생성
                    this.makeApples();

                    // basket 이동 함수 정의
                    this.basket.onMove = function() {
                        //console.log('board knows that the basket moved');

                        //apple check
                        for (let i = 0; i < self.apples.length; i += 1) {
                            let rectangle = self.apples[i].getRectangle();
                            // apple 요소와 겹쳐졌을 때 효과음이 울리며 요소는 사라지고, 점수가 증가한다. 
                            if (self.isOverlapped(rectangle)) {
                                self.apples[i].remove();
                                self.updateScore(APPLE_POINT);
                                self.successAudio.currentTime = 0;
                                self.successAudio.play();
                            }
                        }
                        //orange check
                        for (let i = 0; i < self.oranges.length; i += 1) {
                            let rectangle = self.oranges[i].getRectangle();
                            // orange 요소와 겹쳐졌을 때 효과음이 울리며 요소는 사라지고, 점수가 증가한다.
                            if (self.isOverlapped(rectangle)) {
                                self.oranges[i].remove();
                                self.updateScore(ORANGE_POINT);
                                self.successAudio.currentTime = 0;
                                self.successAudio.play();
                            }
                        }

                        //bomb check
                        for (let i = 0; i < self.bombs.length; i += 1) {
                            let rectangle = self.bombs[i].getRectangle();
                            // bomb 요소와 겹쳐졌을 때 효과음이 울리며 요소는 사라지고, 점수가 감소한다.
                            if (self.isOverlapped(rectangle)) {
                                self.bombs[i].remove();
                                self.updateScore(BOMB_POINT);
                                self.bombAudio.play();
                            }
                        }
                        
                    }

                    // getElementByClassName 메서드를 이용하여 id = 'success'로 요소 객체를 가져와 변수 successAudio를 선언한다.
                    this.successAudio = document.getElementsByClassName('success')[0];
                    // getElementByClassName 메서드를 이용하여 id = 'bomb'으로 요소 객체를 가져와 변수 bombAudio를 선언한다.
                    this.bombAudio = document.getElementsByClassName('bomb')[0];
                    // getElementByClassName 메서드를 이용하여 id = 'fail'로 요소 객체를 가져와 변수 failAudio를 선언한다.
                    this.failAudio = document.getElementsByClassName('fail')[0];
                };

                // 점수 업데이트 함수
                this.updateScore = function(incrementValue) {
                    this.score += incrementValue;
                    // 현재의 점수를 scoreElement에 텍스트로 가져온다.
                    this.scoreElement.innerText = this.score;
                    // 현재 레벨(스테이지) 체크
                    this.checkGameStage();
                };
                
                // 레벨(스테이지) 체크 함수
                this.checkGameStage = function() {
                    // 아직 stage 2가 되지 않은 상태에서 점수가 100점 이상이 되었을 경우 
                    if (this.score >= 100 && this.stage < 2) {
                        // stage 2가 되고 orange 요소와 bomb 요소의 생성이 실행된다.
                        this.stage = 2;
                        this.updateStage();
                        this.makeOranges();
                        this.makeBombs();                        
                    } // 아직 stage 3이 되지 않은 상태에서 점수가 200점 이상이 되었을 경우
                    else if (this.score >= 200 && this.stage < 3) {
                        // stage 3가 되고 worm 요소 생성이 실행된다.
                        this.stage = 3;
                        this.updateStage();
                        this.makeWorms();
                    } // 아직 stage 4이 되지 않은 상태에서 점수가 300점 이상이 되었을 경우
                    else if (this.score >= 300 && this.stage < 4) {
                        // stage 4가 되고 cloud 요소 생성이 실행된다.
                        this.stage = 4;
                        this.updateStage();
                        this.makeClouds();
                    }
                };
                
                // 게임 오버 함수
                this.gameOver = function() {
                    // apple 요소의 타이머가 clear
                    clearInterval(this.appleTimerId);
                    // apple 요소들의 이동 정지
                    for (let i = 0; i < this.apples.length; i += 1) {
                        this.apples[i].stop();
                    }                    

                    // orange 요소의 타이머가 clear
                    clearInterval(this.orangeTimerId);
                    // orange 요소들의 이동 정지
                    for (let i = 0; i < this.oranges.length; i += 1) {
                        this.oranges[i].stop();
                    }

                    // bomb 요소의 타이머가 clear
                    clearInterval(this.bombTimerId);
                    // bomb 요소들의 이동 정지
                    for (let i = 0; i < this.bombs.length; i += 1) {
                        this.bombs[i].stop();
                    }                   

                    // worm 요소의 타이머가 clear
                    clearInterval(this.wormTimerId);
                    for (let i = 0; i < this.worms.length; i += 1) {
                        this.worms[i].stop();
                    }

                    // cloud 요소의 타이머가 clear
                    clearInterval(this.cloudTimerId);
                    // cloud 요소들의 이동 정지
                    for (let i = 0; i < this.clouds.length; i += 1) {
                        this.clouds[i].stop();
                    }

                    // 키 이벤트 무시(작동하지 않음)
                    this.basket.ignoreKeysEvents();
                    // 게임 오버시 점수판 생성
                    this.showGameOverWindow();
                };

                // 점수판 생성 함수
                this.showGameOverWindow = function() {
                    // getElementById 메서드를 이용하여 id = 'gameover'로 요소 객체를 가져와 변수 gameover을 선언한다.
                    let gameOver = document.getElementById('gameOver');
                    // getElementById 메서드를 이용하여 id = 'currentScore'로 요소 객체를 가져와 변수 currentScore을 선언한다.
                    let currentScore = document.getElementById('currentScore');
                    // 'Your score: 현재 점수'의 텍스트 형태로 가져온다.
                    currentScore.innerText = 'Your score: '+ this.score;
                    let scores = this.checkScores();
                    for (let i = 0; i < scores.length; i += 1) {
                        // p 노드 객체를 생성한다.
                        let para = document.createElement('p');
                        para.innerText = `TOP#${i + 1}: ${scores[scores.length - i - 1]}`;
                        // gameover에 para 노드를 삽입한다.
                        gameOver.appendChild(para);
                    }

                    // 게임 오버시 점수판을 보이도록 설정한다.
                    gameOver.style.display = 'block';
                    // 게임 오버시 불투명도를 0.6으로 설정한다.
                    this.element.style.opacity = '0.6';
                };
                
                // 점수 체크 함수
                this.checkScores = function() {
                    // local storage로 부터 SCORE_ARRAY를 읽어온다.
                    let scores = localStorage.getItem(SCORE_ARRAY);
                    // 점수가 false, 0, null, undefined인 경우
                    if (!scores) {
                        // 점수 초기화
                        scores = [];
                        // JSON.stringify를 이용하여 점수를 string으로 바꾸어 setItem에 저장한다.
                        localStorage.setItem(SCORE_ARRAY, JSON.stringify(scores));
                    } // 점수가 있는 경우 다시 JSON 객체로 바꾸어 준다.
                    else {
                        scores = JSON.parse(scores);                
                    }

                    // 이미 저장된 점수(점수판으로 나타날 점수)가 3개 미만일 경우
                    if (scores.length < MAX_SCORES) {
                        // 나타날 점수판에 점수를 저장한다.
                        scores.push(this.score);
                    } // 이미 저장된 점수가 3개 초과될 경우
                    else {
                        scores = scores.sort(function(a, b){return a - b});
                        // 이미 저장된 점수가 현재 점수보다 큰 경우
                        if (parseInt(scores[0]) > this.score) {
                            // 이미 저장된 점수를 반환한다.(현재 점수가 더 낮으면 저장될 필요가 없다.)
                            return scores;
                        }
                        scores[0] = this.score
                    }
                    // JSON.stringify를 이용하여 점수를 string으로 바꾸어 setItem에 저장한다.
                    localStorage.setItem(SCORE_ARRAY, JSON.stringify(scores));
                    // 점수를 배열한다.
                    return scores.sort(function(a, b){return a - b});
                };


                this.makeWorms = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;
                    
                    // 3초에서 (10-3+1)=8초 사이의 무작위 정수 값으로 worm요소가 생성되도록 하는 wormTimerId를 선언한다.
                    this.wormTimerId = setInterval(function() {
                        // worm에 변수 self.element와 randomRange(4, 20)을 저장한 Worm 생성자를 이용하여 객체를 생성하고 선언한다.
                        let worm = new Worm(self.element, randomRange(4, 20));
                        worm.onMove = function(rectangle) {
                            // worm 요소와 겹쳐지면 fail 효과음이 들리면서 게임 오버된다.
                            if (self.isOverlapped(rectangle)) {
                                self.failAudio.play();
                                self.gameOver();
                            }
                        };

                        self.worms.push(worm);
                    }, randomRange(3000, 10000));
                };

                this.makeApples = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;

                    // 1초에서 6초 사이의 무작위 정수 값으로 apple요소가 생성되도록 하는 appleTimerId를 선언한다.
                    this.appleTimerId = setInterval(function(){
                        // apple에 변수 self.element와 randomRange(4, 20)을 저장한 Apple 생성자를 이용하여 객체를 생성하고 선언한다.
                        let apple = new Apple(self.element, randomRange(4, 20));
                        
                        apple.onMove = function(clientRect) {
                            // apple 요소와 겹쳐지면 success 효과음이 들리면서 요소가 사라지고 점수를 획득한다.
                            if (self.isOverlapped(clientRect)) {
                                apple.remove();
                                self.updateScore(APPLE_POINT);
                                self.successAudio.currentTime = 0;
                                self.successAudio.play();
                            }
                        };

                        apple.onDie = function() {
                            for (let i = 0; i < self.apples.length; i += 1) {
                                if (self.apples[i] == apple) {
                                    // i번째에서 한 개의 요소를 빼준다.
                                    self.apples.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        self.apples.push(apple);
                        
                    }, randomRange(1000, 6000));
                };

                this.makeOranges = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;

                    // 1초에서 8초 사이의 무작위 정수 값으로 orange요소가 생성되도록 하는 orangeTimerId를 선언한다.
                    this.orangeTimerId = setInterval(function(){
                        // orange에 변수 self.element와 randomRange(4, 20)을 저장한 Orange 생성자를 이용하여 객체를 생성하고 선언한다.
                        let orange = new Orange(self.element, randomRange(4, 20));
                        
                        orange.onMove = function(clientRect) {
                            // orange 요소와 겹쳐지면 success 효과음이 들리면서 요소가 사라지고 점수를 획득한다.
                            if (self.isOverlapped(clientRect)) {
                                orange.remove();
                                self.updateScore(ORANGE_POINT);
                                self.successAudio.currentTime = 0;
                                self.successAudio.play();
                            }
                        };

                        orange.onDie = function() {
                            for (let i = 0; i < self.oranges.length; i += 1) {
                                if (self.oranges[i] == orange) {
                                    // i번째에서 한 개의 요소를 빼준다.
                                    self.oranges.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        self.oranges.push(orange);
                        
                    }, randomRange(1000, 8000));
                };

                this.makeBombs = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;

                    // 5초에서 (10-5+1)=6초 사이의 무작위 정수 값으로 bomb요소가 생성되도록 하는 bombTimerId를 선언한다.
                    this.bombTimerId = setInterval(function(){
                        // bomb에 변수 self.element와 randomRange(4, 20)을 저장한 Bomb 생성자를 이용하여 객체를 생성하고 선언한다.
                        let bomb = new Bomb(self.element, randomRange(4, 20));
                        
                        bomb.onMove = function(clientRect) {
                            // bomb 요소와 겹쳐지면 bomb 효과음이 들리면서 요소가 사라지고 점수를 잃는다.
                            if (self.isOverlapped(clientRect)) {
                                bomb.remove();
                                self.updateScore(BOMB_POINT);
                                self.bombAudio.currentTime = 0;
                                self.bombAudio.play();
                            }
                        };

                        bomb.onDie = function() {
                            for (let i = 0; i < self.bombs.length; i += 1) {
                                if (self.bombs[i] == bomb) {
                                    // i번째에서 한 개의 요소를 빼준다.
                                    self.bombs.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        self.bombs.push(bomb);
                        
                    }, randomRange(5000, 10000));
                };

                this.makeClouds = function() {
                    // this를 self 변수로 선언한다.
                    let self = this;

                    // 1초에서 6초 사이의 무작위 정수 값으로 cloud요소가 생성되도록 하는 cloudTimerId를 선언한다.
                    this.cloudTimerId = setInterval(function(){
                        // cloud에 변수 self.element와 randomRange(4, 20)을 저장한 Cloud 생성자를 이용하여 객체를 생성하고 선언한다.
                        let cloud = new Cloud(self.element, randomRange(4, 20));
                        
                        cloud.onMove = function(clientRect) {
                            //console.log('cloud moves', clientRect);                            
                        };
                    
                        self.clouds.push(cloud);
                        
                    }, randomRange(1000, 6000));
                };

                // 'stage (현재 점수)'의 텍스트 형태로 가져온다.
                this.updateStage = function() {
                    this.stageElement.innerText = 'stage ' + this.stage;
                };
                
                this.isOverlapped = function(clientRect) {
                    /* getBoundingClientRect을 이용하여 요소의 크기와 방향을 통해 위치 값을 반환하는
                    getClientRect함수로 정의한 것을 basketReact 변수에 선언한다.*/
                    let basketRect = this.basket.getClientRect();

                    if (basketRect.right < clientRect.left + GAP) return false;
                    if (basketRect.left > clientRect.right - GAP) return false;
                    if (basketRect.bottom < clientRect.top + GAP) return false;
                    if (basketRect.top > clientRect.bottom - GAP) return false;
                    
                    return true;
                }

                this.init();
            }

            // n1에서 (n2 - n1 + 1)사이의 무작위 정수 값을 반환한다.
            function randomRange(n1, n2) {
                return Math.floor((Math.random() * (n2 -n1 + 1)) + n1);
            }
        </script>
        </head>
        <body>
            <h1>Fruit <span>in</span> basket</h1>
            <!--div의 id를 stage로 정의-->
            <div id="stage">stage 1</div>
            <!--div의 id를 score로 정의-->
            <div id="score">00</div>
            <!--div의 id를 board로 정의-->
            <div id="board">
                <!--div의 id를 basket으로 정의-->
                <div id="basket"></div>
                <!--
                <div class="apple"></div>
                <div class="orange"></div>
                <div class="bomb"></div>
                <div class="worm"></div>
                <div class="cloud"></div> 
                -->
                <!--div의 id를 gameover로 정의-->
                <div id="gameOver">
                    <!--p의 id를 currentScore로 정의-->                    
                    <p id="currentScore">240</p>
                    <!--
                    <p>TOP #1: 3000</p>
                    <p>TOP #2: 3000</p>
                    <p>TOP #3: 3000</p>
                    -->
                </div>   
            </div>
            <!--audio의 class를 success로 정의하고 wav의 형태로 소리를 연결-->
            <audio class="success">
                <source src="sound/success.wav" type="audio/wav">
            </audio>
            <!--audio의 class를 fail로 정의하고 wav의 형태로 소리를 연결-->
            <audio class="fail">
                <source src="sound/fail.wav" type="audio/wav">
            </audio>
            <!--audio의 class를 bomb으로 정의하고 wav의 형태로 소리를 연결-->
            <audio class="bomb">
                <source src="sound/bomb.wav" type="audio/wav">
            </audio>
        </body>
    </html>